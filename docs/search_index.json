[["index.html", "R 语言最佳实践 (R Best Practice) Chapter 1 前言 preface 1.1 帮助 help", " R 语言最佳实践 (R Best Practice) biomooc.com | version: 0.0.0-5 2022-01-18 11:25:24 Chapter 1 前言 preface 本书目标：总结R语言的最佳实践，特别是可视化方面，并付诸行动，持续提升技能、习惯和思维方式。 覆盖范围，文件摆放 编码习惯，代码结构 函数命名，函数结构，变量命名 并行执行 养成良好的编程习惯重在日常。 一个好的程序应该具备可读性与可理解性。 下面是应该养成的好习惯： 采用结构化、模块化编程 增加注释 使用意义明确的名字给变量命名 行前自动缩进 1.1 帮助 help 本文定位是中高级用户，熟手。 对于还没入门的，请参考入门读物 准备工作，阅读前两个章节。 https://www.biomooc.com/ 生物信息与R语言 QQ 群: 187923577 设置国内镜像来下载包 options(repos=structure(c(CRAN=“https://mirrors.tuna.tsinghua.edu.cn/CRAN/”))) 免费电子书 bookdown.org https://r-graphics.org/ https://r4ds.had.co.nz/ https://rafalab.github.io/dsbook/ https://www.tidytextmining.com/ https://otexts.com/fpp2/ 1.1.1 R包版本信息 version sessionInfo() ## R version 4.1.1 (2021-08-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Matrix products: default ## BLAS: /data/public/R-4.1.1/lib/R/lib/libRblas.so ## LAPACK: /data/public/R-4.1.1/lib/R/lib/libRlapack.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.24 digest_0.6.27 R6_2.5.1 jsonlite_1.7.2 ## [5] magrittr_2.0.1 evaluate_0.14 stringi_1.7.4 rlang_0.4.11 ## [9] rstudioapi_0.13 jquerylib_0.1.4 bslib_0.3.0 rmarkdown_2.11 ## [13] tools_4.1.1 stringr_1.4.0 xfun_0.26 yaml_2.2.1 ## [17] fastmap_1.1.0 compiler_4.1.1 htmltools_0.5.2 knitr_1.34 ## [21] sass_0.4.0 1.1.2 How to Build and publish? push master with code; push gh-pages with html and figs. dir: /home/wangjl/data/rmarkdown_demo/bookdown-demo-main/ 1. 修改好后，增加版本号 index.Rmd 和 changeLog.txt 中一致 2. &gt; build 3. push $ git add . $ git commit -m &#39;xxx&#39; $ git push origin master 3. $ mv docs docs2 1. $ git checkout gh-pages 2. replace docs/ $ rm -rf docs $ mv docs2 docs $ git add docs/ $ git commit -m &#39;20220118&#39; $ git push origin gh-pages $ git checkout master &gt; build # again "],["introduction.html", "Chapter 2 introduction 2.1 为 Rstudio Server 指定R版本", " Chapter 2 introduction 学而时习之，不亦说乎？ 主要是一些常用的可视化细节。碰到了就整理一下。 2.1 为 Rstudio Server 指定R版本 免费的 Rstudio Server 已经不支持为每个用户设置R版本了。要改就是所有用户一起改。改的方法如下： * change R location in /etc/rstudio/rserver.conf: rsession-which-r=/usr/bin/R * restart rstudio-server sudo rstudio-server restart "],["colors.html", "Chapter 3 colors 3.1 1.ggplot2 常用的渐变色 3.2 自定义渐变色(bias 参数) 3.3 Multi Color System 3.4 Single Color System", " Chapter 3 colors 3.1 1.ggplot2 常用的渐变色 library(ggplot2) set.seed(202201) p1=ggplot(data.frame(x=1:30, y=rnorm(30)), aes(x,y, color=x))+ geom_point(size=3, shape=18)+ geom_line(size=0.5)+ theme_classic()+theme( legend.key.width = unit(3, &quot;mm&quot;), legend.key.height = unit(5, &quot;mm&quot;) ) p1 #亮丽彩虹色 p1+scale_color_gradientn(colours =rainbow(30)) #红蓝渐变 p1+scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) #红白蓝渐变scale_color_gradient2(low = &quot;red&quot;, mid = &quot;white&quot;, high = &quot;blue&quot;) #复古彩虹色 p1+scale_color_distiller(palette = &quot;Spectral&quot;) #红黄渐变色 p1+scale_color_distiller(palette=&quot;YlOrRd&quot;, direction=1) #黄绿渐变色 p1+scale_color_viridis_c() #紫黄渐变色scale_color_viridis_d() 3.2 自定义渐变色(bias 参数) # colors for Heatmap showColors=function(bias=1){ # 操纵渐变色的倾向性 #bias=1.5; len=100 clist=c( colorRampPalette( c(&quot;navyblue&quot;, &quot;#91BFDB&quot;, &quot;white&quot;), interpolate=&quot;spline&quot;, bias=bias )(len), &quot;white&quot;, rev(colorRampPalette( c(&quot;firebrick3&quot;, &quot;#F9B596&quot;, &quot;white&quot;), interpolate=&quot;spline&quot;, bias=bias )(len)) ) par(mar=c(2,0,0,0)) barplot(rep(1,length(clist)), col=clist, border = NA, space=0, axes=F, ) axis(side=1, at=seq(0, 1+2*len, length.out=5), labels = seq(-2,2,1), cex=0.2) } showColors(0.5) showColors(1) showColors(1.5) 3.3 Multi Color System colorbar=function(colorlist, main=&quot;&quot;){ barplot(rep(1, length(colorlist)), col=colorlist, border=NA, space=0, axes=F, main=main) } par(mar=c(0,0,1,0)) tropical &lt;- c(&quot;darkorange&quot;,&quot;dodgerblue&quot;,&quot;hotpink&quot;,&quot;limegreen&quot;,&quot;yellow&quot;) colorbar(tropical) springtime &lt;- c(&quot;#f6eb7b&quot;, &quot;#e5769e&quot;, &quot;#b3f281&quot;, &quot;#73a8e3&quot;, &quot;#c184ec&quot;) colorbar(springtime) amy &lt;- c(&quot;#ee693f&quot;, &quot;#b3de81&quot;, &quot;#e8a735&quot;, &quot;#3a5199&quot;, &quot;#ffec5c&quot;) colorbar(amy) cbPalette &lt;- c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) colorbar(cbPalette) 3.4 Single Color System par(mar=c(0,0,1,0)) springgreen &lt;- c(&quot;#7aa14c&quot;, &quot;#86b251&quot;, &quot;#a3d468&quot;, &quot;#b7ea7b&quot;, &quot;#cff99e&quot;) colorbar(springgreen) cleanwater &lt;- c(&quot;#0669a5&quot;, &quot;#0479c1&quot;, &quot;#038de1&quot;, &quot;#18a5fb&quot;, &quot;#4cbbff&quot;) colorbar(cleanwater) "],["literature2.html", "Chapter 4 Literature2 4.1 向高水平文章学习", " Chapter 4 Literature2 4.1 向高水平文章学习 4.1.1 某 Science paper pubmed 整体使用了很多的包，对 library() 语句汇总计数后，排名靠前的包分别是: 某science文章中最高频率的R包，前3个频次超过40次。 ggpubr plyr data.table ggplot2 dplyr sscVis ssscClust reshape2 tictoc ComplexHeatmap cowplot ggrastr R.utils ggsci grid RcolorBrewer circlize Seurat Startrac stringr doParallel ... 还用到了 Gviz 包，可能是画基因峰图的。 4.1.2 按类别整理后如下 画图包 &quot;grid&quot;, https://stat.ethz.ch/R-manual/R-devel/library/grid/doc/index.html &quot;gridBase&quot;, 修饰ggplot2的低层包 &quot;ggplotify&quot;, [Good] Convert plot function call (using expression or formula) to &#39;grob&#39; or &#39;ggplot&#39; object that compatible to the &#39;grid&#39; and &#39;ggplot2&#39; ecosystem. https://www.jianshu.com/p/7a1050d54b31 gridExtra, &quot;ggplot2&quot;, &quot;ggpubr&quot;, [Good]‘ggplot2’ Based Publication Ready Plots https://rpkgs.datanovia.com/ggpubr/ &quot;cowplot&quot;, [Good] 为ggplot2提供一个出版级别的主题 https://www.jianshu.com/p/fea410378360 cowplot添加注释，连接图片 https://www.jianshu.com/p/0ec30fdffbd5 排版 https://www.jianshu.com/p/6400fd3abc56 &quot;ggrastr&quot;, [Good] 像素画点图，保持文字和标签向量化。大幅减少图片体积。 https://github.com/VPetukhov/ggrastr &quot;ggrepel&quot;, repel overlapping text labels &quot;ggvenn&quot;, 韦恩图 https://statisticsglobe.com/ggvenn-r-package &quot;VennDiagram&quot;, https://statisticsglobe.com/venn-diagram-in-r https://www.r-graph-gallery.com/venn-diagram.html https://www.geeksforgeeks.org/how-to-create-a-venn-diagram-in-r/ &quot;patchwork&quot;, [Good]make plot composition in R extremely simple and powerful. https://patchwork.data-imaginist.com/articles/patchwork.html &quot;ggforce&quot;, 注释和分面(椭圆圈住某些点) https://www.jianshu.com/p/9409650971d9 &quot;ggraph&quot;, A grammar of graphics for relational data Layouts https://www.data-imaginist.com/2017/ggraph-introduction-layouts/ https://www.r-bloggers.com/2017/02/introduction-to-ggraph-layouts/ https://ggraph.data-imaginist.com/reference/ggraph.html 所有可以转换为grob对象的图形都可以使用as.ggplot函数转换为ggplot对象 现在有了ggplot对象，我们可以利用cowplot或者patchwork包将所有的图形组合起来。 &quot;ComplexHeatmap&quot;, https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html &quot;circlize&quot;, 一个圆形布局包含扇形(sector)和轨道(track)两个部分 https://www.sohu.com/a/351872019_718302 https://github.com/jokergoo/circlize https://jokergoo.github.io/circlize_book/book/ &quot;gplots&quot;, 用gplots包中的heatmap.2函数就可以画出想要的热图 &quot;igraph&quot;, provides versatile options for descriptive network analysis and visualization in R, Python, and C/C++ https://igraph.org/r/ &quot;png&quot;, &quot;fmsb&quot;, radar plot https://www.datanovia.com/en/blog/beautiful-radar-chart-in-r-using-fmsb-and-ggplot-packages/ 颜色 &quot;ggsci&quot;, offers a collection of ggplot2 color palettes inspired by scientific journals, data visualization libraries, science fiction movies, and TV shows. &quot;RColorBrewer&quot;, &quot;colorRamps&quot;, 数据框处理包 &quot;tidyverse&quot;, &quot;plyr&quot;, &quot;dplyr&quot;, &quot;data.table&quot;, 高效数据框 https://www.jianshu.com/p/01598d707ac4 &quot;reshape2&quot;, https://www.jianshu.com/p/370a04c6b64a 修整数据的内置函数（比如stack、unstack与reshape） &quot;Matrix&quot;, &quot;tibble&quot;, tibble()做的事情更少——这更加符合我们的需要：它从不改变输入数据的类型 https://www.jianshu.com/p/49e8a2d38389 &quot;zoo&quot;, Time Series 时间序列基础库 &quot;stringr&quot;, 一致的、简单易用的字符串工具集 http://blog.fens.me/r-stringr/ https://www.cnblogs.com/nxld/p/6062950.html &quot;magrittr&quot;, 该包定义了管道符 %&gt;% &quot;matrixStats&quot;, 矩阵 Functions that Apply to Rows and Columns of Matrices (and to Vectors) &quot;dendextend&quot;, 树状图 provides general functions for handling tree-like structures in R. [Good] https://mran.microsoft.com/snapshot/2016-10-12/web/packages/dendextend/vignettes/introduction.html meta 分析 &quot;meta&quot;, User-friendly general package providing standard methods for meta-analysis and supporting Schwarzer, Carpenter, and Rücker # w.step2.FigureS32.TCGA_mut_valid.R &quot;esc&quot;, esc: Effect Size Computation for Meta Analysis &quot;forestplot&quot;, 森林图 数学建模 &quot;ranger&quot;, 随机森林 a fast implementation of random forests (Breiman 2001) or recursive partitioning, particularly suited for high dimensional data. &quot;gam&quot;, Generalized Additive Models in R https://www.rdocumentation.org/packages/mgcv/versions/1.8-38/topics/gam &quot;MASS&quot;, 可以多元正态分布数据 https://cran.r-project.org/web/packages/MASS/MASS.pdf &quot;nlme&quot;, 混合线性模型 &quot;webr&quot;, Data and Functions for Web-Based Analysis https://github.com/cardiomoon/webr 生信专用包 &quot;limma&quot;, &quot;survival&quot;, &quot;survminer&quot;, &quot;Gviz&quot;, &quot;motifmatchr&quot;, &quot;Startrac&quot;, 通过Rna-seq和Tcr跟踪进行单T细胞分析 &quot;chromVARmotifs&quot;, make it easy to use several different motif collections in R, particularly for use with motifmatchr and chromVAR packages. 单细胞包(前几个是作者自己写的包，都在github上 https://github.com/Japrin/) &quot;sscVis&quot;, &quot;sscClust&quot;, &quot;scPip&quot;, A pipeline for scRNA-seq data analysis https://github.com/Japrin/scPip &quot;Seurat&quot;,&quot;sctransform&quot;, &quot;harmony&quot;, &quot;monocle3&quot;, &quot;SingleCellExperiment&quot;, &quot;SCENIC&quot;, &quot;scran&quot;, implements methods to perform low-level processing of scRNA-seq data, including cell cycle phase assignment, variance modelling and testing w.step0.10.TCGA_immuneTyping.R # &quot;scReClassify&quot;, a post hoc cell type classification of single-cell RNA-sequencing data to fine-tune cell type annotations generated by any cell type classification procedure. https://bioconductor.org/packages/devel/bioc/vignettes/scReClassify/inst/doc/scReClassify.html # wrapper.reClassify.R &quot;nichenetr&quot;, NicheNet: predict active ligand-target links between interacting cells &quot;SCopeLoomR&quot;, R package (compatible with SCope) to create generic .loom files and extend them with other data e.g.: SCENIC regulons, Seurat clusters and markers, ... https://github.com/aertslab/SCopeLoomR &quot;AUCell&quot;, http://events.jianshu.io/p/c15db7c9d3c5 GO分析与基因注释: &quot;clusterProfiler&quot;, &quot;org.Hs.eg.db&quot;, &quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;, &quot;BSgenome.Hsapiens.UCSC.hg19&quot;, &quot;GSVA&quot;, R语言开发与调试 &quot;tictoc&quot;, Functions for Timing R Scripts, as Well as Implementations of Stack and List Structures &quot;R.utils&quot;, #使用 R.utils 中的 gunzip 解压缩 &quot;rlang&quot;, &quot;argparse&quot;, &quot;reticulate&quot;, &quot;future&quot;, 并行计算 &quot;parallel&quot;, https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf &quot;doParallel&quot;, https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html &quot;BiocParallel&quot;, https://www.r-bloggers.com/2016/03/are-you-doing-parallel-computations-in-r-then-use-biocparallel/ https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Introduction_To_BiocParallel.pdf 查这个包在哪个函数出现过 $ find . | grep &quot;R$&quot; | xargs grep -P &quot;zoo&quot; --color=auto ./source_FigS22_func.R:library(&quot;zoo&quot;) ./source_dyn_func.R:library(&quot;zoo&quot;) $ find . | grep &quot;R$&quot; | xargs grep -P &quot;stringr&quot; --color=auto ./w.step2.FigureS17.CD8_ISG_mapping.R:library(&quot;stringr&quot;) ./w.step2.FigureS22.MAIT_Tex.R:library(&quot;stringr&quot;) ./w.step2.FigureS11.blood_Temra.R:library(&quot;stringr&quot;) $ find . | xargs grep -P &quot;gam&quot; | grep library --color=auto ./w.step2.FigureS17.CD8_ISG_highlight.Rmd:library(&quot;gam&quot;) ./w.step2.FigureS24.CD8_Tex_Dyn.Rmd:library(&quot;gam&quot;) ./w.step1.Figure3.CD4_Tfh_Dyn.Rmd:library(&quot;gam&quot;) ./w.step2.FigureS26.CD4_Treg_Dyn.Rmd:library(&quot;gam&quot;) $ find . | xargs grep -P &quot;ggrastr&quot; --color=auto ./w.step2.FigureS14.CD8_Tex_score.Rmd:library(&quot;ggrastr&quot;) ./w.step2.FigureS17.CD8_ISG_mapping.R:#library(&quot;ggrastr&quot;) ./w.step2.FigureS17.CD8_ISG_highlight.Rmd:library(&quot;ggrastr&quot;) ./w.step2.FigureS13.CD8_global_monocle3.Rmd:library(&quot;ggrastr&quot;) ./w.step2.FigureS25.CD4_Tfh_monocle3.Rmd:library(&quot;ggrastr&quot;) ./w.step2.FigureS26.CD4_Treg_monocle3.Rmd:library(&quot;ggrastr&quot;) ./scenic/run.scenic.step6.comb.R:library(&quot;ggrastr&quot;) ./w.step2.FigureS32.TCGA_mut_valid.R: library(&quot;ggrastr&quot;) ./w.step2.FigureS24.CD8_Tex_Dyn.Rmd:library(&quot;ggrastr&quot;) ./w.step0.04.proliferationScore.R:library(&quot;ggrastr&quot;) ./w.step2.FigureS22.MAIT_Tex.R:library(&quot;ggrastr&quot;) ./w.step1.Figure3.CD4_Tfh_Dyn.Rmd:library(&quot;ggrastr&quot;) ./w.step2.FigureS26.CD4_Treg_Dyn.Rmd:library(&quot;ggrastr&quot;) ./w.step2.FigureS11.blood_Temra.R:library(&quot;ggrastr&quot;) 找R包的官方主页，一般有文档 https://bioconductor.org/packages/release/bioc/html/BiocParallel.html "],["最佳实践.html", "Chapter 5 最佳实践 5.1 Best practices 5.2 文件结构 5.3 代码块 5.4 函数 5.5 图形操作", " Chapter 5 最佳实践 5.1 Best practices what are some tips for writing clean and efficient R code? Best practices: https://krlmlr.github.io/tidyprog/best-practices.html 写注释，写测试 谷歌的风格指导(多语言) https://google.github.io/styleguide/Rguide.html 函数命名使用 BigCamelCase，私有函数则加上 dot 前缀； dot.case 这种命名容易和S3类混淆，不建议使用； Don’t use attach() Right-hand assignment 不要用，容易看不到，且和其他主流语言不同； Use explicit returns，最后一句明写 return(x+y) http://adv-r.had.co.nz/Style.html variable names should be nouns and function names should be verbs. Use an underscore (_) to separate words within a name. Comments should explain the why, not the what. http://www.johnmyleswhite.com/notebook/2010/08/26/projecttemplate/ to automatically run all of the unit tests in your tests directory. run.tests() 学习最佳实践的包：stringr/testthat Best Practices for Writing R Code 使用 git https://swcarpentry.github.io/git-novice/ Be careful when using setwd()，只在开始用，或者不用。 函数单独写到一个文件中，然后引入 source(“my_genius_fxns.R”) 变量命名统一规则，比如 矩阵结尾 _mat，数据框结尾 _df Don’t repeat yourself– 当你开始复制好几行代码的时候，尝试写成循环or函数。否则未来极有可能犯错，代价昂贵。 一个项目的代码放到一个文件夹内，使用相对路径。 在某个文件中记录使用的包的版本号 keep track of sessionInfo() other hints: For efficiency, prefer vector operations over for loops. use a version control system, such as Git; Review and test your code rigorously Don’t save your workspace 5.2 文件结构 只能从代码结构中反推文件结构，比如代码放到哪里，数据放到哪里，输出放到哪里 (1) sce_all = readRDS(sprintf(&quot;%s/../../data/expression/CD8/integration/int.CD8.S35.sce.merged.rds&quot;,oDir)) sce_ref = readRDS(sprintf(&quot;%s/../../data/expression/CD8/integration/int.CD8.S35.HVG.continumOnly.v1.sce.Path.rds&quot;,oDir)) gene_used = read.table(sprintf(&quot;%s/../../data/metaInfo/int.CD8_Tex.genes.txt&quot;,oDir), header=F, stringsAsFactors=F)$V1 colSet = readRDS(sprintf(&quot;%s/../../data/metaInfo/panC.colSet.list.rds&quot;,oDir)) 推测 / /data/ |-metaInfo/ |-int.CD8_Tex.genes.txt |-panC.colSet.list.rds |-expression/ |-CD8 |-integration/ |-int.CD8.S35.sce.merged.rds |-int.CD8.S35.HVG.continumOnly.v1.sce.Path.rds |-xx/ |-yy/ |-OUT_FigS17/ just created |- #here now 5.3 代码块 对于不常用，但是是一起执行的代码，使用{}括起来，整体只需要按一下ctrl+enter即可全部执行，清晰高效。 { a=1 b=2 print(a+b) } 5.4 函数 5.4.1 函数命名的规范化 对于使用超过2次的代码块，包装成函数，放到专门的文件中，供其他脚本source()引用。 $ ls -lth | grep -i func -r--r--r-- 1 wangjl wangjl 9.7K Nov 23 11:34 source_dyn_func.R -r--r--r-- 1 wangjl wangjl 7.3K Nov 5 00:32 source_FigS22_func.R -r--r--r-- 1 wangjl wangjl 84K Sep 30 14:45 func.R 查看一下函数名字，函数名字加点号，中间的单词使用首字母大写。 $ grep -i &quot;function&quot; func.R changeSomeNames &lt;- function(obj,col.mcls=&quot;meta.cluster&quot;,col.ctype=&quot;cancerType&quot;,col.dataset=&quot;dataset&quot;) correctCellInfo &lt;- function(cellInfo.tb) plotNightingaleRose &lt;- function(dat.plot.NightingaleRose,empty_bar=2, do.tissueDist &lt;- function(cellInfo.tb,out.prefix,pdf.width=3,pdf.height=5,verbose=0) test.dist.table &lt;- function(count.dist,min.rowSum=0) count.dist.melt.ext.tb &lt;- as.data.table(ldply(seq_len(nrow(count.dist.melt.tb)), function(i){ fetchMetaClusterID2CusterFullName &lt;- function(col.use=&quot;cluster.name.full&quot;) 计算分裂指数 calProliferationScore &lt;- function(obj,assay.name,gene.prol,out.prefix=NULL,method=&quot;mean&quot;) f.zero &lt;- apply(exp.sub,1,function(x){ all(x==0) }) f.zero &lt;- apply(exp.sub,1,function(x){ all(x==0) }) vis.clonotype &lt;- function(out.prefix, annotation_legend_param &lt;- llply(mcls.sig,function(x){ list(at=sig.pretty) }) annotation_legend_param_prob &lt;- llply(mcls.sig,function(x){ colSet.prob &lt;- llply(mcls.sig,function(x){ ana.clonotypeAcrossMcls.moreThanTwo &lt;- function(object, clone.LLR.tb &lt;- ldply(seq_len(nrow(clone.info.flt.tb)),function(i){ do.plot.bar &lt;- function(dat.block.flt.freq,clone.info.flt.tb, l_ply(seq_along(clone.example.vec),function(i){ makeFig.ExampleGeneBarplot &lt;- function(out.prefix,gene.to.plot, prepare.data.for.plot &lt;- function(dat.long,gene.desc.top,mcls,a.gene,mod.sort=3) dat.fig.list &lt;- llply(gene.to.plot,function(a.gene){ run.clusterProfiler &lt;- function(out.prefix, gene.oi, gene.bg, do.plot.freq.heatmap &lt;- function(dat.plot.a,colSet,mapping.vec,group.var=&quot;meta.cluster&quot;, mcls.cor.max &lt;- apply(cor.dat,1,function(x){ max(abs(x[x!=1])) }) makeHTPlot &lt;- function(dat.in,out.prefix) sigGeneVennPlot &lt;- function(v.list,background.list,out.prefix,col.venn=NULL,fill.venn=NULL,venn.alpha=c(1,0.7,0.7)) sigGeneVennTable &lt;- function(gene.tb,cmp,only.sig=T) function(x){ any(x==T,na.rm=T) }) run.nichenet &lt;- function(gene.oi,gene.bg,out.prefix, function(x){ mean(x,na.rm=T) &gt;= 0.5 }) run.venn.nicheNet.g2 &lt;- function(mcls,sname,out.prefix,gene.bg,...) gen.gsea.script &lt;- function(gene.desc.top,sh.dir,out.prefix,db.file, 函数的参数，使用点号前缀，目的是？为了防止重复？只有函数内部使用点号开头的变量。 $ grep -i &quot;function&quot; source_dyn_func.R heatmap_sm = function (obj, assay.name = &quot;exprs&quot;, out.prefix = NULL, ncell.downsample = NULL, dat.plot = t(apply(dat.plot, 1, function(x){rollmean(x, 50, fill=&quot;extend&quot;)})) ## 2. new functions convertGeneID = function(.genes, .from=&quot;SYMBOL&quot;, .to=&quot;ENSEMBL&quot;){ convertDPTperc = function(.sce){ testOneGene = function(.gene, .sce){ testProcess = function(.sce, .tfs){ plotONEgene = function(.gene, .sce, .colSet){ hyper.test = function(set1, set2, bg){ 5.4.2 没见过或使用较少的函数 (1) sprintf() #好处是和C一致，减少记忆负担。 (2) 开头引入包后，定义文件夹 stype = &quot;CD8&quot; oDir = &quot;./OUT_FigS17/&quot; dir.create(oDir, F, T) # dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = &quot;0777&quot;) (3) ggsave, 及其参数 useDingbats=F(方便后期AI处理图片) print(p) #要打出来图才能保存 ggsave(p, file=sprintf(&quot;%s/%s_ISG.mapping.umap.pdf&quot;,oDir, stype), width=5.5, height=8, useDingbats=F) 5.5 图形操作 用到了很多 ggpubr 包 用到了 ggplot2 图形基本操作。 画热图，用到了 ComplexHeatmap 包，并用 grid 做参数整合。 对 seurat 掰开揉碎了，写到自己的包里了。 "],["functions.html", "Chapter 6 functions 6.1 函数的定义 6.2 返回函数的函数 6.3 df 相关函数", " Chapter 6 functions 函数是R语言的一级公民，只要有响应的地方都是有函数在执行。 6.1 函数的定义 6.2 返回函数的函数 6.3 df 相关函数 6.3.1 横向合并表格(cbind/merge) # 如果合并依赖的列没有重复值 course=data.frame( id=c(101,102,100), course=c(&quot;math&quot;, &quot;english&quot;, &quot;IT&quot;), row.names =paste0(&quot;v1_&quot;, 1:3) ) course ## id course ## v1_1 101 math ## v1_2 102 english ## v1_3 100 IT score=data.frame( sid=c(1,2,2), cid=c(100,101,102), value=c(100,91,82), row.names =paste0(&quot;v2_&quot;, 1:3) ) score ## sid cid value ## v2_1 1 100 100 ## v2_2 2 101 91 ## v2_3 2 102 82 # 如果不做检查校验，直接简单拼接 cbind(course, score) ## id course sid cid value ## v1_1 101 math 1 100 100 ## v1_2 102 english 2 101 91 ## v1_3 100 IT 2 102 82 # 如果需要按某一列合并，比如学生不同科目的成绩 m1=merge(course, score, by.x=&quot;id&quot;, by.y=&quot;cid&quot;); m1 # 基于没重复值的列 merge后，行数不变，失去 rowname ## id course sid value ## 1 100 IT 1 100 ## 2 101 math 2 91 ## 3 102 english 2 82 # 如果有重复值，行数会变多，返回的是基于该同值的行的各种组合 student=data.frame( id=c(1,2, 1), #身份证 name=c(&quot;Jack&quot;, &quot;Robin&quot;, &quot;Jack2&quot;) #教职员工考的在职研究生 ) student ## id name ## 1 1 Jack ## 2 2 Robin ## 3 1 Jack2 merge(student, score, by.x=&#39;id&#39;, by.y=&quot;sid&quot;) ## id name cid value ## 1 1 Jack 100 100 ## 2 1 Jack2 100 100 ## 3 2 Robin 101 91 ## 4 2 Robin 102 82 "],["plots.html", "Chapter 7 Plots 7.1 ggplot2 特殊用法 7.2 ggplot2 主题及自定义主题 7.3 图片瘦身(ggrastr) 7.4 为paper配色而生(ggsci包) 7.5 图片布局(grid, gridExtra) 7.6 拼接图形(gridExtra/ cowplot/ patchwork) 7.7 ggExtra 画边缘分布 7.8 相关分析(去掉共线性的变量) 7.9 pheatmap 热图(成熟) 7.10 ComplexHeatmap 热图(功能多) 7.11 dendextend 给聚类图上色 7.12 标文字 ggrepel 避免重叠", " Chapter 7 Plots Some significant applications are demonstrated in this chapter. 7.1 ggplot2 特殊用法 library(ggplot2) # 1.旋转分面标题的文字 # Rotate Strip Text in ggplot2 https://stackoverflow.com/questions/48892826/rotate-strip-text-in-ggplot2 ggplot(mtcars, aes(mpg, disp, color=factor(carb) ))+ geom_point()+ facet_grid(gear~.)+ theme_classic()+ theme( strip.background = element_blank(), panel.border = element_rect(fill=&quot;#00112200&quot;), strip.text.y = element_text(angle=60, color=&#39;red&#39;), legend.position = &#39;none&#39; #不显示图例 ) 7.2 ggplot2 主题及自定义主题 我们平常修改主题就是在 theme() 中写很多规则，这样很灵活，但是不方便复用。 对于常用的规则，最好是包装成返回一堆 theme 规则的函数，类似 theme_bw()，方便复用、方便记忆。 下面2个主题函数分别来自 Seurat(4.0.4)包和 ggplot2 自带，我们可以模仿，来自定义主题。 &gt; Seurat::NoLegend function (...) { no.legend.theme &lt;- theme(legend.position = &quot;none&quot;, validate = TRUE, ...) return(no.legend.theme) } &gt; Seurat::NoAxes function (..., keep.text = FALSE, keep.ticks = FALSE) { blank &lt;- element_blank() no.axes.theme &lt;- theme(axis.line.x = blank, axis.line.y = blank, validate = TRUE, ...) if (!keep.text) { no.axes.theme &lt;- no.axes.theme + theme(axis.text.x = blank, axis.text.y = blank, axis.title.x = blank, axis.title.y = blank, validate = TRUE, ...) } if (!keep.ticks) { no.axes.theme &lt;- no.axes.theme + theme(axis.ticks.x = blank, axis.ticks.y = blank, validate = TRUE, ...) } return(no.axes.theme) } &gt; theme_bw function (base_size = 11, base_family = &quot;&quot;, base_line_size = base_size/22, base_rect_size = base_size/22) { theme_grey(base_size = base_size, base_family = base_family, base_line_size = base_line_size, base_rect_size = base_rect_size) %+replace% theme(panel.background = element_rect(fill = &quot;white&quot;, colour = NA), panel.border = element_rect(fill = NA, colour = &quot;grey20&quot;), panel.grid = element_line(colour = &quot;grey92&quot;), panel.grid.minor = element_line(size = rel(0.5)), strip.background = element_rect(fill = &quot;grey85&quot;, colour = &quot;grey20&quot;), legend.key = element_rect(fill = &quot;white&quot;, colour = NA), complete = TRUE) } # 这些数据是 dput() 输出的 dat1=structure(list(year = 2020:2000, all = c(4561L, 4393L, 4359L, 3756L, 3744L, 3674L, 3346L, 2955L, 2597L, 2652L, 2747L, 2878L, 2928L, 2640L, 2570L, 2762L, 2787L, 2623L, 2830L, 3093L, 2932L ), en = c(4312L, 4115L, 3983L, 3482L, 3450L, 3416L, 3156L, 2734L, 2367L, 2425L, 2509L, 2675L, 2734L, 2433L, 2396L, 2589L, 2606L, 2425L, 2624L, 2884L, 2758L), wa = c(224L, 240L, 327L, 260L, 271L, 238L, 168L, 208L, 214L, 215L, 224L, 184L, 161L, 189L, 157L, 156L, 161L, 181L, 183L, 187L, 152L)), row.names = c(NA, 21L), class = &quot;data.frame&quot;) head(dat1) ## year all en wa ## 1 2020 4561 4312 224 ## 2 2019 4393 4115 240 ## 3 2018 4359 3983 327 ## 4 2017 3756 3482 260 ## 5 2016 3744 3450 271 ## 6 2015 3674 3416 238 # 自定义主题 theme_guardian = function(...){ require(grid) theme_grey(...)+ #基于预设主题 theme( #plot.background = element_blank(), plot.caption = element_text(color = &quot;grey30&quot;, face = &quot;italic&quot;, margin=margin(t=4, unit=&quot;pt&quot;), hjust = 0, size=10), #底部数据源 plot.title = element_text(hjust = 0, size=12), #大标题 panel.grid.major.y = element_line(color=&quot;grey70&quot;, size=0.5), panel.background = element_blank(), #不要灰背景 panel.grid.major.x = element_blank(), #不要竖线 axis.line.x = element_blank(), axis.ticks = element_line(color=&quot;grey70&quot;), axis.text = element_text(color=&quot;grey70&quot;), axis.title = element_text(color=&quot;grey70&quot;, size=14), axis.title.x = element_text(margin=margin(t=5, unit=&quot;pt&quot;)), axis.title.y = element_text(margin=margin(r=5, unit=&quot;pt&quot;)), legend.position = &quot;top&quot;, legend.justification = &quot;left&quot;, legend.key.size = unit(10, unit=&quot;pt&quot;), legend.background = element_blank(), ) } library(ggplot2) # fig1: #library(ggthemes) g1=ggplot(dat1, aes(year, all))+geom_line(color=&quot;darkred&quot;)+ labs(x=&quot;Year of death registration&quot;, y=&quot;The number of deaths&quot;, caption = &quot;Guardian graphic. Source:ONS&quot;, title=&quot;There were 4,561 drug posoning deaths in England and Wales in 2020- the eighth consecutive annual rise&quot;)+ theme_guardian()+ #使用自定义主题 annotate(&quot;text&quot;, x=2020, y=4671, label=&quot;4,561&quot;, color=&quot;darkred&quot;)+ geom_point(data=data.frame(x=2020, y=4561), aes(x,y), size=2, color=&quot;darkred&quot;); #g1 #pdf(&quot;g1.pdf&quot;, width=4.5, height=4, useDingbats = F) print(g1) #dev.off() # fig2: colors=c(&quot;#BB2924&quot;, &quot;#306B9F&quot;) #dat2=read.table(&quot;dat2.txt&quot;, header = T) dat2=structure(list(year = 2020:2000, M = c(21.7, 19.5, 18.1, 11.8, 11, 9.4, 7.3, 4.8, 4.1, 3.1, 4.4, 6.2, 6.8, 5.7, 5.8, 5.3, 4.6, 4, 4, 2.8, 2.4), F = c(5.5, 5.1, 4.1, 3.3, 1.9, 1.8, 1.4, 1.2, 0.7, 0.8, 0.6, 0.8, 1.3, 1.1, 0.9, 0.9, 0.8, 0.6, 0.6, 0.7, 0.5 )), class = &quot;data.frame&quot;, row.names = c(NA, -21L)) library(tidyr) dat3=pivot_longer(dat2, cols=c(&quot;M&quot;, &quot;F&quot;)) dat3$name=factor(dat3$name, levels=c(&quot;M&quot;, &quot;F&quot;)) head(dat3) ## # A tibble: 6 × 3 ## year name value ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 2020 M 21.7 ## 2 2020 F 5.5 ## 3 2019 M 19.5 ## 4 2019 F 5.1 ## 5 2018 M 18.1 ## 6 2018 F 4.1 p1=ggplot()+ geom_line(data=dat3, mapping=aes(year, value, color=name ))+ labs(x=&quot;Year of death registration&quot;, y=&quot;The Rate of Deaths involving Cocaine(%)&quot;, caption = &quot;Guardian graphic. Source:ONS, age-standardised mortality rates&quot;, title=&quot;The rate of male deaths involving cocaine has increased shaply since 2010&quot;)+ theme_guardian()+ #使用自定义主题 scale_color_manual(name=&quot;&quot;, values = colors)+ guides(color = guide_legend(override.aes = list(size = 5)))+ annotate(&quot;text&quot;, x=2020, y= c(max(dat2$M), max(dat2$F))+2, label=c(max(dat2$M), max(dat2$F)), color=colors)+ geom_point(data=data.frame(x=2020, y=c(max(dat2$M), max(dat2$F)) ), aes(x,y), size=2, color=colors); #p1 #pdf(&quot;g2.pdf&quot;, width=5, height=4.5, useDingbats = F) print(p1) #dev.off() 使用 grid 包还能继续修改该图形。比如把上图的图例修改为圆角矩形(links)。 7.3 图片瘦身(ggrastr) ggrastr: Rasterize Layers for ‘ggplot2’ 作用: 生成栅格图、矢量文字。 生成pdf的时候，图片瘦身效果明显，1.4M 栅格化后只有200k。 library(ggrastr) library(ggplot2) #pdf(&quot;my_output/test1.pdf&quot;, width=4, height=3) ggplot(diamonds, aes(carat, price, color=cut))+ #geom_point(size=0.1)+ geom_point_rast(size=0.1, raster.dpi = getOption(&quot;ggrastr.default.dpi&quot;, 300),)+ #图片瘦身：点图不是是矢量，文字是 theme_classic()+ guides(color = guide_legend(override.aes = list(size = 3))) #dev.off() Ubuntu 安装报错 Please install cairo (http://www.cairographics.org/) and/or set CAIRO_CFLAGS/LIBS correspondingly ... ERROR: dependencies ‘Cairo’, ‘ragg’ are not available for package ‘ggrastr’ Shell https://cairographics.org/download/ # apt-get install libcairo2-dev # R &gt; BiocManager::install(&quot;ggrastr&quot;) Configuration failed to find the harfbuzz freetype2 fribidi library. Try installing: * deb: libharfbuzz-dev libfribidi-dev (Debian, Ubuntu, etc) Shell # apt-get install libharfbuzz-dev libfribidi-dev # R &gt; BiocManager::install(&quot;ggrastr&quot;) Configuration failed to find one of freetype2 libpng libtiff-4. Try installing: * deb: libfreetype6-dev libpng-dev libtiff5-dev libjpeg-dev (Debian, Ubuntu, etc) Shell # apt-get install libfreetype6-dev libpng-dev libtiff5-dev libjpeg-dev # R &gt; BiocManager::install(&quot;ggrastr&quot;) ... * DONE (ggrastr) 7.4 为paper配色而生(ggsci包) 包含各种sci-fi主题的调色盘！ scale_color_palname() scale_fill_palname() 就包含了 nature, Lancet, NEJM，JAMA,JCO等顶级杂志的配色风格 library(ggplot2) library(dplyr) library(ggsci) library(gridExtra) p1 = ggplot(subset(diamonds, carat &gt;= 2.2), aes(x = table, y = price, colour = cut) )+ geom_point(alpha = 0.7) + geom_smooth(method = &quot;loess&quot;, alpha = 0.05, size = 1, span = 1) + theme_bw() p2 = ggplot(subset(diamonds, carat &gt; 2.2 &amp; depth &gt; 55 &amp; depth &lt; 70), aes(x = depth, fill = cut)) + geom_histogram(colour = &quot;#00112200&quot;, binwidth = 1, position = &quot;dodge&quot;) + theme_bw() # NPG配色 p1_npg = p1 + scale_color_npg() p2_npg = p2 + scale_fill_npg() grid.arrange(p1_npg, p2_npg, ncol = 2)##grid组图 # 新英格兰医学杂志配色 grid.arrange(p1 + scale_color_nejm(), p2 + scale_fill_nejm(), ncol = 2) # 柳叶刀杂志配色 scale_color_lancet(), scale_fill_lancet(), # JAMA配色 scale_color_jama(), scale_fill_jama(), set.seed(202201) p1=diamonds %&gt;% sample_n(1000) %&gt;% ggplot()+ aes(x=cut,y=price,fill=cut) + geom_boxplot()+ theme_classic() p1+scale_fill_lancet() # 动画主题 p1+scale_fill_rickandmorty() 7.4.1 获取颜色16进制值 nejm&lt;-pal_nejm(&quot;default&quot;,alpha = 1)(8)##(9表示呈现多少个颜色) nejm ## [1] &quot;#BC3C29FF&quot; &quot;#0072B5FF&quot; &quot;#E18727FF&quot; &quot;#20854EFF&quot; &quot;#7876B1FF&quot; &quot;#6F99ADFF&quot; ## [7] &quot;#FFDC91FF&quot; &quot;#EE4C97FF&quot; library(scales) scales::show_col(nejm, cex_label = 0.8 ) #scales::show_col( ggsci::rgb_material(&quot;red&quot;), cex_label = 0.6 ) #scales::show_col( ggsci::rgb_material(&quot;blue&quot;), cex_label = 0.6 ) scales::show_col( ggsci::rgb_material(&quot;purple&quot;), cex_label = 0.6 ) 7.5 图片布局(grid, gridExtra) 在grid包中，grob是一个可编辑的绘图对象，grob是graphical object两个单词的前两个字符的组合。常用于表示ggplot对象、lattice等高级图形系统创建图形对象。 grid.arrange()函数，不仅能够控制个数已知的图形布局，还能对控制未知个数的图形布局，功能十分强大。 arrangeGrob()和grid.arrange()函数 这两个布局函数的区别是：arrangeGrob()返回未绘制的grob，而grid.arrange()函数在当前的设备上绘图图形。 library(grid) library(gridExtra) library(ggplot2) # 创建对象 g1=ggplot(mtcars, aes(disp, mpg))+geom_point()+theme_classic();g1 g2=ggplot(iris, aes(Species, Sepal.Length, fill=Species))+ geom_violin()+theme_classic()+labs(x=&quot;&quot;)+ theme( axis.text.x = element_text(angle=60, hjust = 1), legend.position = &quot;none&quot;);g2 # (1) 两列 grid.arrange(g1, circleGrob(), rectGrob(width=0.8, height=0.5), g2, ncol = 2) # (2) 控制每行每列的宽高比例 grid.arrange(g1, g2, circleGrob(), rectGrob(width=0.9), ncol=2, nrow=2, widths=c(3,5), heights=c(4,1)) # (3) 绘图对象合并为一个list参数传入 gs=list() gs[[1]]=g1 gs[[2]]=g2 # gs grid.arrange(grobs=gs,ncol = 2) # (4) 使用 rbind.gtable 合并后再画图 gA &lt;- ggplotGrob(g1) gB &lt;- ggplotGrob(g2) grid::grid.newpage() grid::grid.draw(rbind(gA, gB)) 7.5.1 更精细控制布局:使用 layout_matrix=矩阵 # 共三列，1/3, 2/3 grid.arrange(g1, g2, layout_matrix = matrix(c(1, 2, 2), ncol = 3)) # 还可以留空白 grid.arrange(g1, g2, layout_matrix = matrix(c(1, NA, NA, NA, 2, 2), byrow = TRUE, ncol = 3)) # 更复杂的布局 lay &lt;- rbind(c(1,1,1,2,3), c(1,1,1,4,5), c(6,7,8,9,9)) grid.arrange(grobs = gs, layout_matrix = lay) 7.5.2 图中图 # 把 ggplot2 对象转变为 grob 对象 g2_2=ggplot2::ggplotGrob(g2) grid.draw(g2_2) # 通过添加注释(annotate)的方式，向一个图形内部添加一个小图形 #参数解释 # xmin、xmax、ymin、ymax # 添加图形在大图中的四个点的坐标 # grob # 要添加的小图对象 grid.newpage() g1 + annotation_custom(grob = g2_2, xmin = 250, xmax = 450, ymin = 20, ymax = 35) 7.6 拼接图形(gridExtra/ cowplot/ patchwork) 创建带边缘分布的散点图，边缘分布图和中间的主图坐标怎么对齐呢？ - 可以尝试 cowplot 包的 plot_grid 函数的 align 函数实现坐标对齐。 - 或者 patchwork 包的 plot_layout 函数。 library(RColorBrewer) # 模拟数据 set.seed(202201) df1 &lt;- data.frame(x=c(rnorm(1000, mean=1),rnorm(3000, mean=4.5)), y=c(rnorm(3000, mean=-1.6),rnorm(1000, mean=2.2)) ) # 二维分布云图 p1&lt;-ggplot(df1, aes(x, y)) + #geom_hex(bins = 40,na.rm=TRUE)+ #填充单元形状设定为六边形 geom_bin2d (bins=40,na.rm=TRUE) + #填充单元形状设定为正方形 scale_fill_gradientn(colours=rev(brewer.pal(11,&#39;Spectral&#39;)))+ theme_classic() p1 # 二维分布密度图 p2&lt;-ggplot(df1, aes(x, y)) + stat_density_2d (geom =&quot;raster&quot;,aes(fill = ..density..),contour = F)+ #栅格形填充 # stat_density_2d (geom =&quot;polygon&quot;,aes(fill = ..level..),bins=30 )+ #多边形填充 scale_fill_gradientn(colours= rev(brewer.pal(11,&#39;Spectral&#39;)))+ theme_classic() p2 # 效果1: 二维分布云图+边缘直方图 #建立空白图形面板 empty&lt;-ggplot()+ theme(panel.background = element_rect(fill=&quot;white&quot;, color=&quot;white&quot;)) # 绘制顶部直方图 hist_top &lt;- ggplot(df1, aes(x)) + geom_histogram(colour=&quot;black&quot;,fill=&#39;#5E4FA2&#39;,size=0.25)+ theme_void() # 绘制右边的直方图 hist_right &lt;- ggplot(df1, aes(y)) + geom_histogram(colour=&quot;black&quot;,fill=&#39;#5E4FA2&#39;,size=0.25)+ theme_void()+ coord_flip() #旋转坐标轴 #绘制云图 scatter&lt;-ggplot(df1, aes(x, y)) + #stat_density2d(geom =&quot;polygon&quot;,aes(fill = ..level..),bins=30 )+ stat_binhex(bins = 15,na.rm=TRUE,color=&quot;black&quot;)+# scale_fill_gradientn(colours=rev(brewer.pal(11,&#39;Spectral&#39;)))+ theme_minimal()+theme( legend.position = &quot;none&quot; ) # 最终的组合 grid.newpage() grid.arrange(hist_top, empty, p1+theme( legend.position = &quot;none&quot;), hist_right, ncol=2, nrow=2, widths=c(4,1), heights=c(1,4)) # grid.arrange(hist_top, empty, scatter, hist_right, ncol=2, nrow=2, widths=c(4,1), heights=c(1,4)) # 或者先返回对象，再画出来 p5=arrangeGrob(hist_top, empty, scatter, hist_right, ncol=2, nrow=2, widths=c(4,1), heights=c(1,4)) p5 ## TableGrob (2 x 2) &quot;arrange&quot;: 4 grobs ## z cells name grob ## 1 1 (1-1,1-1) arrange gtable[layout] ## 2 2 (1-1,2-2) arrange gtable[layout] ## 3 3 (2-2,1-1) arrange gtable[layout] ## 4 4 (2-2,2-2) arrange gtable[layout] grid.draw(p5) # 效果2: 二维密度云图+边缘密度图 # 绘制顶部直方图 hist_top &lt;- ggplot(df1, aes(x)) + geom_density(colour=&quot;black&quot;,fill=&#39;#5E4FA2&#39;,size=0.25)+ theme_void() # 绘制右边的直方图 hist_right &lt;- ggplot(df1, aes(y)) + geom_density(colour=&quot;black&quot;,fill=&#39;#5E4FA2&#39;,size=0.25)+ theme_void()+ coord_flip() #绘制云图 scatter&lt;-ggplot(df1, aes(x, y)) + #stat_density2d(geom =&quot;polygon&quot;,aes(fill = ..level..),bins=30 )+ stat_density2d(geom =&quot;raster&quot;,aes(fill = ..density..),bins = 15,na.rm=TRUE,contour = F,alpha=1)+# scale_fill_gradientn(colours=rev(brewer.pal(11,&#39;Spectral&#39;)))+ theme_minimal()+ theme(panel.background=element_rect(fill=&quot;white&quot;,colour=&quot;black&quot;,size=0.25), legend.position = &quot;none&quot; ) # 最终的组合 grid.arrange(hist_top, empty, scatter, hist_right, ncol=2, nrow=2, widths=c(4,1), heights=c(1,4)) 7.6.1 cowplot 拼接图 拼接方法: https://zhuanlan.zhihu.com/p/384189537 library(cowplot) plot_grid(hist_top, empty, p1+theme( legend.position = &quot;none&quot;), hist_right, ncol = 2, #labels = &quot;XX&quot;, hjust = -0.5, vjust = 1, align = &quot;hv&quot;, # h 和 v 方向都对齐 #scale = 1, rel_widths = c(4, 1), rel_heights = c(1, 4)) # 坐标轴的对齐 https://wilkelab.org/cowplot/articles/aligning_plots.html 7.6.2 patchwork 拼接图 library(patchwork) hist_top + plot_spacer() + # patchwork的函数，自动添加一个空白块 (p1+theme( legend.position = &quot;none&quot;)) + hist_right + plot_layout( ncol = 2, nrow = 2, widths = c(4, 1), heights = c(1, 4) ) 7.7 ggExtra 画边缘分布 # https://www.r-graph-gallery.com/277-marginal-histogram-for-ggplot2 # https://github.com/daattali/ggExtra p0&lt;-ggplot(df1, aes(x, y)) + geom_point(color=&quot;slateblue&quot;, alpha=0.2, size=0.2)+ scale_fill_gradientn(colours=rev(brewer.pal(11,&#39;Spectral&#39;)))+ theme_classic() # p0 library(ggExtra) ggMarginal( (p0+theme( legend.position = &quot;none&quot;)), type=&quot;boxplot&quot;, fill = &quot;slateblue&quot;) grid.newpage() ggMarginal( (p0+theme( legend.position = &quot;none&quot;)), type=&quot;density&quot;, fill = &quot;slateblue&quot;) grid.newpage() ggMarginal( (p0+theme( legend.position = &quot;none&quot;)), type=&quot;histogram&quot;, fill = &quot;slateblue&quot;) grid.newpage() ggMarginal( (p0+theme( legend.position = &quot;none&quot;)), type=&quot;histogram&quot;, fill = &quot;slateblue&quot;, xparams = list( bins=10)) 7.8 相关分析(去掉共线性的变量) # Finding highly correlated variables library(corrplot) M=cor(na.omit(mtcars)) corrplot(M, method = &quot;circle&quot;, type = &quot;lower&quot;, tl.srt = 45, tl.col = &quot;black&quot;, tl.cex = 0.75) 7.9 pheatmap 热图(成熟) https://r-charts.com/correlation/pheatmap/ https://www.rdocumentation.org/packages/pheatmap/versions/1.0.12/topics/pheatmap 中文教程 library(&quot;pheatmap&quot;) # cutree_rows 分成4份 pheatmap( mtcars, scale=&quot;column&quot;, border_color = NA, cutree_rows = 4) # 显示数字 pheatmap(mtcars,scale=&quot;column&quot;,border=NA, display_numbers = T, # 热图上显示数值 fontsize_number = 6, #文字大小 number_color=&quot;darkred&quot;, #文字颜色 #number_format=&quot;%.1e&quot;, #数值显示类型, 如 科学计数法 cutree_cols = 3,cutree_rows =4, #对行列分块 # main=&quot;Gene1&quot;, angle_col = 90, #列名旋转 clustering_distance_rows = &quot;minkowski&quot;, clustering_method=&quot;complete&quot;, cluster_cols = T,treeheight_col = 20, cluster_rows = T,treeheight_row = 20) # 还可以标记正负号，小于0是-，大于1是++，0-1之间是+ pheatmap(mtcars,scale=&quot;column&quot;,border=NA, display_numbers = matrix(ifelse(mtcars &gt; 0, ifelse(mtcars&gt;1, &quot;++&quot;, &quot;+&quot;), &quot;-&quot;), nrow(mtcars)), #输入为矩阵 main=&quot;&quot;) # 添加行注释和列注释 #p &lt;- pheatmap(data, # annotation_col = annotation_col, # annotation_row = annotation_row) # 保存为pdf #p &lt;- pheatmap(data, # filename = &quot;基因家族热图.pdf&quot;, width = 10, height = 8) 7.10 ComplexHeatmap 热图(功能多) 官方文档 # Create test matrix test = matrix(rnorm(200), 20, 10) test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3 test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2 test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4 colnames(test) = paste(&quot;Sample&quot;, 1:10, sep = &quot;&quot;) rownames(test) = paste(&quot;Gene&quot;, 1:20, sep = &quot;&quot;) test[1:3,1:4] ## Sample1 Sample2 Sample3 Sample4 ## Gene1 2.769402 -0.7855350 2.610273 -1.121647 ## Gene2 4.525462 -0.5226219 1.621674 1.322747 ## Gene3 2.230146 2.0127457 3.949946 1.760211 7.10.1 pheatmap() 过渡函数 ComplexHeatmap::pheatmap() 过渡函数，仅仅是为了方便用户从 pheatmap 包无痛过渡。 library(ComplexHeatmap) #v1 basic version pheatmap( as.matrix(test), border_color = NA, #&quot;#00112200&quot;, scale = &quot;row&quot;, main=&quot;1&quot;) #v2, add more annotation # Generate annotations for rows and columns annotation_col = data.frame( CellType = factor(rep(c(&quot;CT1&quot;, &quot;CT2&quot;), 5)), Time = 1:5 ) rownames(annotation_col) = paste(&quot;Sample&quot;, 1:10, sep = &quot;&quot;) head(annotation_col) ## CellType Time ## Sample1 CT1 1 ## Sample2 CT2 2 ## Sample3 CT1 3 ## Sample4 CT2 4 ## Sample5 CT1 5 ## Sample6 CT2 1 # annotation_row = data.frame( GeneClass = factor(rep(c(&quot;Path1&quot;, &quot;Path2&quot;, &quot;Path3&quot;), c(10, 4, 6))) ) rownames(annotation_row) = paste(&quot;Gene&quot;, 1:20, sep = &quot;&quot;) head(annotation_row) ## GeneClass ## Gene1 Path1 ## Gene2 Path1 ## Gene3 Path1 ## Gene4 Path1 ## Gene5 Path1 ## Gene6 Path1 # Specify colors ann_colors = list( Time = c(&quot;white&quot;, &quot;firebrick&quot;), CellType = c(CT1 = &quot;#1B9E77&quot;, CT2 = &quot;#D95F02&quot;), GeneClass = c(Path1 = &quot;#7570B3&quot;, Path2 = &quot;#E7298A&quot;, Path3 = &quot;#66A61E&quot;) ) # 除了图例，其他还是很一致的 pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, border_color = NA, annotation_colors = ann_colors) pheatmap::pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, border_color = NA, annotation_colors = ann_colors) 7.10.2 Heatmap() 主力热图函数 正经功能还是推荐使用 ComplexHeatmap::Heatmap() 函数。 ComplexHeatmap::pheatmap()内部其实使用了Heatmap()函数，因此更多的参数都最终传递给了Heatmap()。 我们可以在pheatmap()中使用一些Heatmap()特有的参数，比如row_split和column_split来对行和列进行切分。 Heatmap(test) #可见，主函数默认是不带边框的，符合预期 # km/row_km:对列进行聚类拆分 Heatmap(test, name = &quot;row_km&quot;, km = 4) # 按照行进行分割聚类：column_km Heatmap(test, name = &quot;column_km&quot;, column_km = 4) # 自定义颜色，这主要是通过circlize包中的colorRamp2()函数来实现的 library(circlize) Heatmap(test, col = colorRamp2(c(-5,0,5), c(&quot;green&quot;,&quot;white&quot;,&quot;red&quot;)), cluster_rows = T, cluster_columns = FALSE) #拼接 #ComplexHeatmap::pheatmap()返回一个Heatmap对象，因此它可以与其他Heatmap/HeatmapAnnotation对象连接。 # 换句话说，你可以使用炫酷的+或者%v%对多个pheatmap水平连接或者垂直连接。 p1=Heatmap(test, name=&quot;mat1&quot;) p2=rowAnnotation(foo=anno_barplot(1:nrow(test))) p3=Heatmap(test, name=&quot;mat2&quot;, col=c(&quot;navy&quot;, &#39;white&#39;, &#39;firebrick3&#39;)) grid.newpage() p1 + p2 + p3 p1+p3 # 水平条注释 va1 = HeatmapAnnotation( dist1 = anno_barplot( #等号左侧的名字能否不显示呢？ colSums(test), bar_width = 1, border = F, #不要边框 #height = unit(2, &quot;cm&quot;), axis_param = list(at = c(0, 20, 40, 60), labels = c(&quot;0&quot;, &quot;20&quot;, &quot;40&quot;, &quot;60&quot;)), gp = gpar(col=&quot;white&quot;, fill = 1:10)), show_annotation_name = F)# 不显示这个bar的名字 va2 = HeatmapAnnotation( foo = anno_boxplot(test, #默认显示这个bar的名字是等号左侧的名字 height = unit(2, &quot;cm&quot;), border = F, #不要边框 gp = gpar(fill = 1:10))) grid.newpage() va1 %v% Heatmap(test, name=&quot;mat1&quot;) %v% va2 #Heatmap(test, name=&quot;mat1&quot;, height = unit(10, &quot;cm&quot;), top_annotation = va2) # 控制顶部的高度 Heatmap(test, name = &quot;base mean&quot;, top_annotation = HeatmapAnnotation(summary = anno_boxplot(test, height = unit(1, &quot;cm&quot;), gp = gpar(fill = 1:10))), height = unit(0.6, &quot;npc&quot;)) # 竖直条注释 rowAnnotation ha = rowAnnotation(foo = anno_histogram(test, n_breaks = 20, gp = gpar(fill = 1:10))) ha2 = rowAnnotation(foo2 = anno_boxplot(test)) ha3 = rowAnnotation(foo3 = anno_density(test)) ha3_ = rowAnnotation(foo4 = anno_density(test, joyplot_scale = 2,#height of peaks gp = gpar(fill = 1:20) )) ha+ha2+ha3+ha3_ # 竖直条注释 2 ha4 = rowAnnotation(foo4 = anno_barplot( rowSums(test&gt;4), border = T, gp = gpar(fill = 1:10, col=&quot;#00112200&quot;))) ha5 = rowAnnotation(foo5 = anno_density(test, type = &quot;violin&quot;, gp = gpar(fill = 1:10))) # when too many rows, space maybe small, then use heatmap ha5_ = rowAnnotation(foo5_ = anno_density(test, type = &quot;heatmap&quot;, #width = unit(2, &quot;cm&quot;), border = T)) ha5_2 = rowAnnotation(foo5_2 = anno_density(test, type = &quot;heatmap&quot;, width = unit(2, &quot;cm&quot;), heatmap_colors = c(&quot;white&quot;, &quot;orange&quot;))) #a better color schema ha4 + ha5+ha5_+ha5_2 7.10.3 为条形图加barplot(顶/右) # 模仿 https://jokergoo.github.io/ComplexHeatmap-reference/book/more-examples.html 14.2 mat=as.matrix(mtcars) # top ha1 = HeatmapAnnotation( dist1 = anno_barplot( colSums(mat), bar_width = 1, gp = gpar(col = &quot;white&quot;, fill = &quot;#FFE200&quot;), border = FALSE, axis_param = list(at = c(0, 2000, 4000, 6000, 8000), labels = c(&quot;0&quot;, &quot;2k&quot;, &quot;4k&quot;, &quot;6k&quot;, &quot;10k&quot;)), height = unit(2, &quot;cm&quot;) ), show_annotation_name = FALSE) # right ha2 = rowAnnotation( dist2 = anno_barplot( rowSums(mat), bar_width = 1, gp = gpar(col = &quot;white&quot;, fill = &quot;#FFE200&quot;), border = FALSE, axis_param = list(at = c(0, 300, 600), labels = c(&quot;0&quot;, &quot;0.3&quot;, &quot;0.6&quot;)), width = unit(1.5, &quot;cm&quot;) ), show_annotation_name = FALSE) #draw(ha2) # x axis text 底部坐标文字 x_text = colnames(mat) #x_text[year_text %% 10 != 0] = &quot;&quot; ha_column = HeatmapAnnotation( year = anno_text(x_text, rot = 60, location = unit(1, &quot;npc&quot;), just = c(&#39;right&#39;, &quot;top&quot;) ) ) # 热图 col_fun = colorRamp2(c(0, 20, 200, 472), c(&quot;white&quot;, &quot;cornflowerblue&quot;, &quot;yellow&quot;, &quot;red&quot;)) ht_list = Heatmap( mat, name = &quot;XX01&quot;, #图例 col = col_fun, cluster_columns = FALSE, show_row_dend = FALSE, rect_gp = gpar(col= &quot;white&quot;), show_column_names = FALSE, row_names_side = &quot;left&quot;, #左侧显示文字 row_names_gp = gpar(fontsize = 8), column_title = &#39;Car dataset\\nProduced at 2022&#39;, top_annotation = ha1, #top bar bottom_annotation = ha_column, #底部文字 heatmap_legend_param = list(at = c(0, 150, 300, 450), labels = c(&quot;0&quot;, &quot;150&quot;, &quot;300&quot;, &quot;450&quot;))) + ha2 #右侧bar draw(ht_list, ht_gap = unit(3, &quot;mm&quot;)) # 添加修饰竖线，虚线 decorate_heatmap_body(&quot;XX01&quot;, { i = which(colnames(mat) == &quot;wt&quot;) x = i/ncol(mat) grid.lines(c(x, x), c(0, 1), gp = gpar(lwd = 2, lty = 2)) grid.text(&quot;yy point&quot;, x, unit(1, &quot;npc&quot;) + unit(5, &quot;mm&quot;)) }) 7.10.4 仅注释特定几个基因 自定义行注释，仅注释特定几个基因 rowAnnotation https://blog.csdn.net/weixin_39942995/article/details/111985755 https://www.jianshu.com/p/eb8548cf73c4 gene=c(&quot;Gene18&quot;, &quot;Gene19&quot;, &quot;Gene7&quot;,&quot;Gene3&quot;, &quot;Gene9&quot;, &quot;Gene15&quot;) gene_pos=which(rownames(test) %in% gene) #3 7 9 15 18 19 #右侧要注释的基因 row_anno=rowAnnotation(gene=anno_mark(at=gene_pos, #位置 labels=gene, #文字 labels_gp=gpar(fontsize=8, col=&quot;red&quot;))) #样式 Heatmap( test, heatmap_legend_param = list(title=&quot;&quot;), #修改图例标题，该语句或者 name=语句 show_row_names = F, #不显示右侧注释 right_annotation = row_anno) #只显示感兴趣基因 7.11 dendextend 给聚类图上色 # BiocManager::install(&quot;dendextend&quot;) library(dendextend) df1=mtcars row_dend = hclust(dist(df1)) # row clustering col_dend = hclust(dist(t(df1))) # column clustering # plot(row_dend ) #plot( color_branches(row_dend, k = 4), leaflab = &quot;none&quot;) plot( color_branches(row_dend, k = 4), #染色 leaflab = &quot;none&quot;, #不显示叶子标签 lwd=10, #怎么加粗？ cex=10, #怎么加粗？ horiz = T ) #水平放置 library(ComplexHeatmap) library(grid) Heatmap(scale(df1), name = &quot;mtcars&quot;, row_names_gp = gpar(fontsize = 6.5), cluster_rows = color_branches(row_dend, k = 4), cluster_columns = color_branches(col_dend, k = 2)) 7.12 标文字 ggrepel 避免重叠 https://ggrepel.slowkow.com/articles/examples.html library(ggplot2) library(ggrepel) ggplot(mtcars, aes(wt, mpg, label = rownames(mtcars), colour = factor(cyl))) + geom_point()+ geom_label_repel(aes(fill=factor(cyl)), #填充背景 colour=&quot;white&quot;, #文字颜色 segment.colour=&quot;black&quot;)+ #连线颜色 theme_bw() ## Warning: ggrepel: 19 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps "],["grid.html", "Chapter 8 grid 8.1 坐标系统 unit(1, “npc”) 8.2 基本图形及图形参数 gp=gpar() 8.3 图形对象 Grob 对象 及其排布、放置 8.4 视口(viewport) 8.5 行列布局 layout 8.6 视口路径 Viewport paths 8.7 grid 的渐变色 8.8 拆解 ggplot2 对象 8.9 扩展 8.10 ref", " Chapter 8 grid grid 绘图系统极其灵活、强大，几乎能绘制任何图形，当然代价是很繁琐。 grid 包是 ggplot2 / ComplexHeatmap 等的底层包。 grid 包的创建者 Paul Murrell’s Home Page: https://www.stat.auckland.ac.nz/~paul/ grid 的核心概念有： 坐标系统 unit(1, “npc”) 基本图形 grid.circle() 与 gpar()对象 图形对象 Grob 对象 及其排布、放置 视口 viewport 及其嵌套、导航 创建新画布 grid.newpage() 8.1 坐标系统 unit(1, “npc”) 所谓坐标系统，主要就是坐标的单位系统。 unit(x, units, data=NULL) 例: 默认的单位 npc 是相对概念，把当前视口的长宽标准化到 0-1。 左下角是(0,0)，右上角是(1,1)。 library(grid) grid.text(label = &quot;Let&#39;s us begin!&quot;) #默认画到中间 grid.text(label = &quot;2nd line&quot;, x=unit(0.1, &quot;npc&quot;), y=0.8, just=&quot;left&quot;, #相对于(x,y)点的左边 rot = -10, #旋转30度(和数学一致，+为逆时针) gp=gpar(col=&quot;purple&quot;, cex=2, face=&quot;bold&quot;)) #紫色、2倍、黑体 坐标系统：描述 native: 位置和大小相对于当前 viewport 的x、y轴的范围 npc: 定义当前 viewport 的左下角(0,0)，右上角(1,1) snpc: 位置和大小被表示为当前 vewport 的宽度和高度中更小的值的比例 inches: 英寸，(0,0)表示 viewport 的左下角 cm: 厘米 mm: 毫米 points: 点，每英寸相当于 72.27 个点 bigpts: 大点，每英寸相当于72个大点 picas: 1 pica 相当于12个点 dida: 1157 个 dida 相当于 1238 个点 cicero: 1 cicero 相当于 12 个 dida scaledpts: 相当于一个点的 65536 分之一 char: 相当于字体大小为单位(由 fontsize 和 cex 确定) lines: 相当于以线条高度为单位(由 fontsize, cex, lineheight 确定) strwidth, strheight: 相当于以字符串的宽高为单位(由 fontsize, cex, fontfamily, fontface 确定) grobwidth, grobheight: 以给定图形对象的宽高位单位。 8.2 基本图形及图形参数 gp=gpar() 绘制图形要指定坐标，指定长宽等参数，而其他参数则由 gp=gpar() 设定。 常用的绘图函数: a1=ls(“package:grid”);a1[grep(“grid.” a1)] grid.rect(…) grid.lines(…) grid.polygon(…) grid.circle(…) grid.text(…) 用gapr对象表示图形参数： col: Colour for lines and borders. fill: Colour for filling rectangles, polygons, … alpha: Alpha channel for transparency lty: Line type lwd: Line width lex: Multiplier applied to line width lineend: Line end style (round, butt, square) linejoin: Line join style (round, mitre, bevel) linemitre: Line mitre limit (number greater than 1) fontsize: The size of text (in points) cex: Multiplier applied to fontsize fontfamily: The font family fontface: The font face (bold, italic, …) lineheight: The height of a line as a multiple of the size of text font: Font face (alias for fontface; for backward compatibility) 8.2.1 使用 rect.rect() 绘制矩形 library(grid) grid.rect() #默认是充满视口(viewport) # 自定义矩形 grid.rect( x=0.5, y=0.8, #设置矩形的位置 just = &quot;left&quot;, #坐标的相对位置 width=0.4, height=0.2, #宽高 gp=gpar(col=&quot;red&quot;, #边框颜色 lwd=3, # 边框宽度 fill=&quot;#00112200&quot;, #填充色 lty=2) #边框虚线 ) # 自定义圆 grid.circle(x = 0.5, y = 0.3, r = 0.25, gp = gpar(col = &quot;blue&quot;, lty = 3, lwd=2)) 8.2.2 绘制嵌套的圆环，并在顶部添加文字 library(grid) suffix &lt;- c(&quot;even&quot;, &quot;odd&quot;) for (i in 1:8) grid.circle( #画图 name = paste0(&quot;circle.&quot;, suffix[i %% 2 + 1]), #名字 r = (9 - i) / 20, #半径 gp = gpar( col = NA, #边框颜色 fill = grey(i / 10) #填充颜色 ) ) # 在顶部添加文字 vp1=viewport(x=0.5, y=0.95, width=0.3, height=0.15) pushViewport(vp1) grid.text(&quot;Circles and rings&quot;, gp=gpar(col=&quot;red&quot;)) upViewport() 8.3 图形对象 Grob 对象 及其排布、放置 grob, or gList, or gTree, or gPath. 8.3.1 Grob 对象 每一个绘图原语都对应一个Grob，grob的命名格式是**Grob，Grob对象是一个可编辑的图形组件，该组件保留图形的所有属性，但不会立即输出图形： rectGrob(…) linesGrob(…) polygonGrob(…) circleGrob(…) textGrob(..) 要输出Grob表示的图形，可以使用grid.draw()函数绘制图形： grid.draw(roundrectGrob(width=0.9, height=0.9)) #一行画一个圆角矩形 circ1 &lt;- circleGrob(r=0.4) grid.draw(circ1) 8.3.2 grid.edit circ1 &lt;- circleGrob(r=0.4, name=&quot;circleX&quot;) grid.draw(circ1) # 获取对象 obj1=grid.get(&quot;circleX&quot;) #就是 Grob的name属性 # 编辑对象，接收 gPath grid.edit( &quot;circleX&quot;, gp = gpar( col = &quot;red&quot;, fill=&quot;orange&quot;, lwd=3 ) ) 如果传入 grob 对象，则要使用 editGrob() 函数 circ1 &lt;- circleGrob(r=0.4, name=&quot;circleX&quot;) circ2=editGrob(circ1, gp = gpar(col=&quot;blue&quot;, lwd=7) ) grid.draw(circ2) 8.3.3 对象排布 gList, or gTree grob() and gTree() are the basic creators, grobTree() and gList() take several grobs to build a new one. gTree 能包含多个 grob 子对象。 candy &lt;- circleGrob(r = 0.1, x = 0.5, y = 0.6) stick &lt;- segmentsGrob(x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 0.5) lollipop &lt;- gTree(children = gList(candy, stick)) #组合两个对象 # 一组内可以一起编辑，都设置成红色 lollipop2=editGrob(lollipop, gp=gpar(col=&quot;red&quot;, lwd=2)) grid.draw(lollipop) # 新视口 pushViewport( viewport(x=0.8, width=0.5,height = 0.5)) grid.draw(lollipop2) # 查看树结构 grid.ls(lollipop2) ## GRID.gTree.5032 ## GRID.circle.5030 ## GRID.segments.5031 8.3.4 gPath //todo 8.3.5 使用grobX和grobY获得grob对象的坐标 grid.newpage() r1 &lt;- rectGrob(0.5, 0.5, width = 0.8, height = 0.8, #just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(col=&quot;red&quot;, lty=2, fill=&quot;#00112200&quot;), name=&quot;r1&quot;) grid.draw(r1) # grobX(obj, theta)# 相对于obj的边界，起始点是obj的中心，转theta角度后在x轴的投影坐标 grid.text(&quot;0-0&quot;, x=grobX(r1, 0), y=grobY(r1, 0)) grid.text(&quot;90-0&quot;, x=grobX(r1, 90), y=grobY(r1, 0)) grid.text(&quot;180-0&quot;, x=grobX(r1, 180), y=grobY(r1, 0)) #grid.text(&quot;270-0&quot;, x=grobX(r1, 270), y=grobY(r1, 0)) #和90-0重叠 #grid.text(&quot;360-0&quot;, x=grobX(r1, 360), y=grobY(r1, 0)) #和0-0重叠 # grobY(obj, theta) #相对于obj的中心，旋转theta角度后在y轴边界上的投影坐标 grid.text(&quot;0-90&quot;, x=grobX(r1, 0), y=grobY(r1, 90), gp=gpar(col=&quot;red&quot;)) #grid.text(&quot;0-180&quot;, x=grobX(r1, 0), y=grobY(r1, 180), gp=gpar(col=&quot;red&quot;)) #和0-0重叠 grid.text(&quot;0-270&quot;, x=grobX(r1, 0), y=grobY(r1,270), gp=gpar(col=&quot;red&quot;)) #和0-0重 # 剩下的坐标轴方位 grid.text(&quot;90-90&quot;, x=grobX(r1, 90), y=grobY(r1, 90), gp=gpar(col=&quot;blue&quot;)) #顶部 grid.text(&quot;270-270&quot;, x=grobX(r1, 270), y=grobY(r1, 270), gp=gpar(col=&quot;blue&quot;)) #底部 # 其余2个对角线 grid.text(&quot;180-90&quot;, x=grobX(r1, 180), y=grobY(r1, 90), gp=gpar(col=&quot;purple&quot;)) #左上角 grid.text(&quot;180-270&quot;, x=grobX(r1, 180), y=grobY(r1, 270), gp=gpar(col=&quot;purple&quot;)) #左下角 # 加一个点，使用两种坐标系指定位置 grid.points(x=unit(0.5, &quot;npc&quot;)/2, y=grobY(r1, 90)/4, pch=19, size=unit(0.04, &quot;npc&quot;), gp=gpar(col=&quot;#FF000099&quot;)) # 点下方添加文字描述 grid.text(&quot;box1&quot;, x=unit(0.5, &quot;npc&quot;)/2, y=grobY(r1, 90)/4 - unit(2, &quot;mm&quot;), just = &quot;top&quot;, gp=gpar(col=&quot;red&quot;) ) # 加一个箭头，中心指向矩形的右上角 grid.segments(0.5, 0.5, grobX(r1, 0), grobY(r1, 90), arrow=arrow(angle=15, type=&quot;closed&quot;), gp=gpar(fill=&quot;orange&quot;)) # 再加一个矩形2 r2 &lt;- rectGrob(0.5, 0.5, width = 0.2, height = 0.2, just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(col=&quot;blue&quot;, fill=&quot;#00112200&quot;), name=&quot;r2&quot;) grid.draw(r2) # 在矩形中间添加文字 grid.text(&quot;box2&quot;, x=grobX(r2, 90), y=grobY(r2, 0), gp=gpar(col=&quot;#0000FF99&quot;) ) # 箭头指向，中心指向矩形的下边中点 grid.segments(0.5, 0.5, grobX(r2, 90), grobY(r2, -90), arrow=arrow(angle=15, type=&quot;closed&quot;), gp=gpar(fill=&quot;grey&quot;, col=&quot;red&quot;)) #红边、灰色填充 # 矩形1的左下角，指向矩形2的右下角 grid.segments(grobX(r1, 180), grobY(r1, -90), grobX(r2, 0), grobY(r2, -90), arrow=arrow(angle=5, type=&quot;closed&quot;), gp=gpar(fill=&quot;purple&quot;, col=&quot;purple&quot;)) # 矩形2的右边中点，指向矩形1的右下角，大箭头 grid.segments(grobX(r2, 0), grobY(r2, 0), grobX(r1, 0), grobY(r1, -90), arrow=arrow(angle=20, type=&quot;closed&quot;), gp=gpar(fill=&quot;red&quot;, col=&quot;grey&quot;)) 8.4 视口(viewport) viewport是grid包的核心对象，简单来说，它就是画布中的一个矩形的绘图区域，直译为视口，通过viewport()函数新建一个viewport对象。 视口就是绘图区，每个绘图对象都在某个视口中。 当前视口是唯一能绘图、编辑的视口。 视口可以嵌套成树状结构，可以选择、删除 创建的视口只有推入视口树中才能生效。 有了viewport这个工具，我们就可以很灵活的在图形中画出任意区域分割的子图了。 viewport(x = unit(0.5, &quot;npc&quot;), y = unit(0.5, &quot;npc&quot;), width = unit(1, &quot;npc&quot;), height = unit(1, &quot;npc&quot;), default.units = &quot;npc&quot;, just = &quot;centre&quot;, gp = gpar(), clip = &quot;inherit&quot;, xscale = c(0, 1), yscale = c(0, 1), angle = 0, layout = NULL, layout.pos.row = NULL, layout.pos.col = NULL, name = NULL) - x：视口的几何中心点相对页面左下角原点的x坐标轴，默认单位是npc - y：视口的几何中心点相对页面左下角原点的y坐标轴，默认单位是npc - width：视口的宽度（x轴方向） - height：视口的高度（y轴方向） - default.units：默认单位为npc (Normalised Parent Coordinates)，含义是规范化化的父区域坐标 - just：x和y所指的位置，默认为矩形中心位置 - gp：gpar对象，用于设置图形参数； - clip：裁剪区域，有效值是“on”，“inherit”或“off”，指示剪裁到视口范围内，从父视口继承剪裁区域，或者完全关闭剪裁。 为了后向兼容性，逻辑值TRUE对应于“on”，而FALSE对应于“inherit” - xscale，yscale：两个数值元素的向量，用于表示坐标轴的最小值和最大值。 - angle：把视口逆时针旋转的角度 - layout：布局（grid.layout）对象，用于把视口划分为多个子区域 - layout.pos.row，layout.pos.col：子区域在父布局中的行位置和列位置 - name：此视口的名字，用于搜索和定位 8.4.1 函数grid.show.viewport()查看创建的视口 height和width是矩形的长和宽，x和y是视口中心点（也就是，矩形的几何中心点）距离x坐标抽和y坐标轴的距离。 vp1 &lt;- viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25, angle=30) grid.show.viewport(vp1) 8.4.2 视口可以旋转 grid.newpage() grid.rect() # 定义视口 vp1=viewport( x=0.5, y=0.4, width=0.6, height=0.2, angle=30 #逆时针旋转 ) # 把视口推入当前位置，称为当前视口 pushViewport(vp1) # 在当前视口绘图 grid.rect(gp=gpar(col=&quot;red&quot;, lty=2)) grid.text(&quot;in the vewport&quot;, x=0,y=1, just=c(&quot;left&quot;, &quot;top&quot;)) 8.4.3 viewport树 视口支持嵌套成树状结构。 当前视口是唯一可编辑的区域，可以把某个视口设为当前视口。 通过5个函数实现对viewport树的遍历和更新： 使用pushViewport()可以将指定的viewport插入到当前viewport的子节点中，同时当前viewport对象移动为刚刚插入的viewport； 使用popViewport()可以删除当前viewport，同时当前viewport改为刚刚删除的viewport的父节点； 使用upViewport()当前viewport移动到父节点； 使用downViewport()当前viewport移动到指定name的子节点； 使用seekViewport()在整棵树范围内搜索指定name的viewport，将其设置为当前viewport。 upViewport(0) 回到根视口 注意：当向树中push一个viewport时，如果树中存在一个级别（level）相同，名字相同的viewport，那么push操作会把该viewport替换掉。 绘制的图形依次嵌套，这说明，每push一次，原活跃viewport都变成父节点，把当前的veiwport作为子viewport。 后续的旋转都是相对于当前视口的旋转。 grid.newpage() grid.rect() #第一个视口是默认的 grid.text(&quot;viewport root&quot;, x=0, y=1, just=c(&quot;left&quot;, &#39;top&#39;)) #在矩形左上角写字 # 新建视口2，并推入 pushViewport( viewport( width=0.8, height=0.5, angle=30 ) ) grid.rect(gp=gpar(lty=2, col=&quot;red&quot;)) #矩形框 grid.text(&quot;viewport2&quot;, x=0, y=1, just=c(&quot;left&quot;, &#39;top&#39;)) #在矩形左上角写字 # 继续嵌套视口3 pushViewport( viewport( width=0.8, height=0.5, angle=30, name=&quot;vp3&quot;)) #视口3有一个名字 grid.rect(gp=gpar(lty=2, col=&quot;orange&quot;)) #矩形框 grid.text(&quot;viewport3&quot;, x=0, y=1, just=c(&quot;left&quot;, &#39;top&#39;)) #在矩形左上角写字 # 继续嵌套视口4 pushViewport( viewport( width=0.9, height=0.7, angle=30, gp=gpar(fill=&quot;#00112200&quot;) ) ) #视口4填充为透明 grid.rect(gp=gpar(lty=2, col=&quot;blue&quot;)) #矩形框 grid.text(&quot;viewport4&quot;, x=0, y=1, just=c(&quot;left&quot;, &#39;top&#39;)) #在矩形左上角写字 # 返回上一个视口，3 upViewport() grid.text(&quot;viewport3&quot;, x=1, y=0, just=c(&quot;right&quot;, &#39;bottom&#39;), gp=gpar(col=&quot;orange&quot;)) #在矩形右下角写字 # 返回上一个视口，2 upViewport() grid.text(&quot;viewport2&quot;, x=1, y=0, just=c(&quot;right&quot;, &#39;bottom&#39;), gp=gpar(col=&quot;red&quot;)) #在矩形右下角写字 # 找到视口名 seekViewport(name=&quot;vp3&quot;) # 在中间添加一个圆 grid.circle(gp=gpar(col=&quot;orange&quot;, lty=2, fill=&quot;#00112200&quot;)) #填充为透明 upViewport(0) #回到最顶部 print(current.vpTree()) # 查看当前viewport树结构 ## viewport[ROOT]-&gt;(viewport[GRID.VP.1244]-&gt;(viewport[vp3]-&gt;(viewport[GRID.VP.1245]))) 8.5 行列布局 layout grid包中定义了布局对象，布局是矩形的子分区，也就是说，布局（layout）把一个矩形区域细分为更小的分区。 grid.layout(nrow = 1, ncol = 1, widths = unit(rep_len(1, ncol), &quot;null&quot;), heights = unit(rep_len(1, nrow), &quot;null&quot;), default.units = &quot;null&quot;, respect = FALSE, just=&quot;centre&quot;) 参数注释： nrow,ncol：布局分为多少个行和列，每一个行和列构成的单元叫做分区（subdivision） widths，heights：每一个分区的宽和高 default.units：默认单位 respect：逻辑值，如果为true，指定行高度和列宽度都遵守。 just：指定对齐方式，有效的值是：&quot;left&quot;, &quot;right&quot;, &quot;centre&quot;, &quot;center&quot;, &quot;bottom&quot;, 和 &quot;top&quot;. 8.5.1 grid.show.layout(layout) 查看布局 把top.vp视口分割为3X3的分区，使用函数grid.show.layout()查看布局，创建的布局如下图所示： layout &lt;- grid.layout(nrow=3, ncol=3, widths=unit(c(5, 1, 2), c(&quot;lines&quot;, &quot;null&quot;, &quot;lines&quot;)), heights=unit(c(5, 1, 4), c(&quot;lines&quot;, &quot;null&quot;, &quot;lines&quot;))) top.vp &lt;-viewport(layout=layout, name=&quot;top&quot;) # viewport 的 layout参数 grid.show.layout(layout) 创建一系列的viewport，占用布局的各个分区，由于没有push任何viewport，因此画布中没有绘制任何图形。 为每个视口命名时，使用统一的格式：margin+数值，如下代码所示： margin1 &lt;- viewport(layout.pos.col = 2, layout.pos.row = 3, name = &quot;margin1&quot;) #(3,2) margin2 &lt;- viewport(layout.pos.col = 1, layout.pos.row = 2, name = &quot;margin2&quot;) #(2,1) margin3 &lt;- viewport(layout.pos.col = 2, layout.pos.row = 1, name = &quot;margin3&quot;) #(1,2) margin4 &lt;- viewport(layout.pos.col = 3, layout.pos.row = 2, name = &quot;margin4&quot;) #(2,3) plot &lt;- viewport(layout.pos.col = 2, layout.pos.row = 2, name = &quot;plot&quot;) #(2,2) # R用数字来表示位置，数值代表的含义是：1=Buttom，2=Left，3=Top，4=Right，视口被布局分割的分区如下图 splot = vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot)) grid.newpage() pushViewport(splot) # 1bottom seekViewport(&quot;margin1&quot;) grid.rect(gp=gpar(col=&quot;grey&quot;, lwd=2)) grid.text(&quot;margin1&quot;, x=0,y=1,just=c(&#39;left&#39;,&#39;top&#39;), gp=gpar(col=&quot;grey&quot;)) # 2left seekViewport(&quot;margin2&quot;) grid.rect(gp=gpar(col=&quot;grey&quot;, lwd=2)) grid.text(&quot;margin2&quot;, x=0,y=1,just=c(&#39;left&#39;,&#39;top&#39;), gp=gpar(col=&quot;grey&quot;)) # 3top seekViewport(&quot;margin3&quot;) grid.rect(gp=gpar(col=&quot;grey&quot;, lwd=2)) grid.text(&quot;margin3&quot;, x=0,y=1,just=c(&#39;left&#39;,&#39;top&#39;), gp=gpar(col=&quot;grey&quot;)) # 4right seekViewport(&quot;margin4&quot;) grid.rect(gp=gpar(col=&quot;grey&quot;, lwd=2)) grid.text(&quot;mg4&quot;, x=0,y=1,just=c(&#39;left&#39;,&#39;top&#39;), gp=gpar(col=&quot;grey&quot;)) # 5 mid seekViewport(&quot;plot&quot;) grid.rect(gp=gpar(col=&quot;black&quot;, lwd=2)) grid.xaxis() grid.yaxis() grid.text(&quot;plot&quot;, x=0,y=1,just=c(&#39;left&#39;,&#39;top&#39;), gp=gpar(col=&quot;grey&quot;)) 8.5.2 拼装散点图 library(grid) layout &lt;- grid.layout(nrow=3, ncol=3, widths=unit(c(5, 1, 2), c(&quot;lines&quot;, &quot;null&quot;, &quot;lines&quot;)), heights=unit(c(5, 1, 4), c(&quot;lines&quot;, &quot;null&quot;, &quot;lines&quot;))) #grid.show.layout(layout) top.vp &lt;-viewport(layout=layout,name=&quot;top&quot;) #grid.show.viewport(top.vp) set.seed(202201) x &lt;- runif(10) y &lt;- runif(10) xscale &lt;- extendrange(x) #grDevices 包基础函数 坐标轴量变留一小段空白 yscale &lt;- extendrange(y) margin1 &lt;- viewport(layout.pos.col = 2, layout.pos.row = 3, name = &quot;margin1&quot;) margin2 &lt;- viewport(layout.pos.col = 1, layout.pos.row = 2, name = &quot;margin2&quot;) margin3 &lt;- viewport(layout.pos.col = 2, layout.pos.row = 1, name = &quot;margin3&quot;) margin4 &lt;- viewport(layout.pos.col = 3, layout.pos.row = 2, name = &quot;margin4&quot;) plot &lt;- viewport(layout.pos.col = 2, layout.pos.row = 2, name = &quot;plot&quot;,xscale = xscale, yscale = yscale) splot &lt;- vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot)) #grid.show.viewport(splot) pushViewport(splot) seekViewport(&quot;plot&quot;) grid.xaxis() grid.yaxis() grid.rect() grid.points(x, y,pch=20) seekViewport(&quot;margin1&quot;) grid.text(&quot;Random X&quot;, y = unit(1, &quot;lines&quot;)) seekViewport(&quot;margin2&quot;) grid.text(&quot;Random Y&quot;, x = unit(1, &quot;lines&quot;), rot = 90) 8.5.3 print.ggplot(g1, vp=) 拼合 ggplot2 图形 方法1: 使用行列布局 print.ggplot()函数。这个函数有一个选项vp，可以指定这个图形要绘制的viewport的位置。 # step1，创建多个图形 library(grid) library(ggplot2) # prepare ggplot charts p.hist.len &lt;- ggplot(iris) + geom_histogram(aes(x=Sepal.Length))+theme_classic() p.hist.wid &lt;- ggplot(iris) + geom_histogram(aes(x=Sepal.Width)) + coord_flip()+theme_classic() p.scatter &lt;- ggplot(iris) + geom_point(aes(x=Sepal.Length, y=Sepal.Width))+theme_classic() # step2，创建布局，分割视口，并push当前视口 grid.newpage() pushViewport(viewport(layout = grid.layout(3, 3))) # step3，把图形输出到布局的不同区域中 print(p.scatter, vp=viewport(layout.pos.row=2:3, layout.pos.col=1:2)) print(p.hist.len, vp=viewport(layout.pos.row=1, layout.pos.col=1:2)) print(p.hist.wid, vp=viewport(layout.pos.row=2:3, layout.pos.col=3)) 方法2: 使用视口不同方法 使用print(, newpage=F)函数。 # top left panel grid.newpage() vp.len &lt;- viewport(x=0, y=0.66, width=0.66, height=0.34, just=c(&quot;left&quot;, &quot;bottom&quot;)) pushViewport(vp.len) print(p.hist.len, newpage=F) upViewport() # 返回父节点 # bottom right panel vp.wid &lt;- viewport(x=0.66, y=0, width=0.34, height=0.66, just=c(&quot;left&quot;, &quot;bottom&quot;)) pushViewport(vp.wid) print(p.hist.wid, newpage=F) upViewport() # bottom left panel vp.scatter &lt;- viewport(x=0, y=0, width=0.66, height=0.66, just=c(&quot;left&quot;, &quot;bottom&quot;)) pushViewport(vp.scatter) print(p.scatter, newpage=F) upViewport() 8.6 视口路径 Viewport paths 可以使用视口路径来选择某个视口，适合选择不同级别的同名视口。 grid.newpage() pushViewport(viewport(name = &quot;A&quot;)) pushViewport(viewport(name = &quot;B&quot;)) pushViewport(viewport(name = &quot;A&quot;)) seekViewport(&quot;A&quot;) current.vpTree(FALSE) ## viewport[A]-&gt;(viewport[B]-&gt;(viewport[A])) # 通过 vpPath() 函数选择B下面的A seekViewport(vpPath(&quot;B&quot;, &quot;A&quot;)) current.vpTree(FALSE) ## viewport[A] # 所谓的 vp 路径，就是::连起来的 viewport 名字 vpPath(&quot;A&quot;, &quot;B&quot;) ## A::B # seekViewport(vpPath(&quot;A&quot;, &quot;B&quot;)) 等价于seekViewport(&quot;A::B&quot;) 8.7 grid 的渐变色 # 一共wid，居中对齐，共n份，有2个0.5是在外面的，每份长度 wid/(n-1) grid.newpage() wid=0.5 n=20 #n越大，渐变色条越细腻 grid.rect(x = unit(seq(0.1, 0.1+wid, length=n), &quot;npc&quot;), #unit(0.5, &quot;npc&quot;), y = 0.5, width = unit(wid/(n-1), &quot;npc&quot;), height = 0.5, just = &quot;center&quot;, gp = gpar(col = NA, fill =colorRampPalette(c(&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;))(n) ) ) grid.lines(x=c(0.1, 0.1), gp=gpar(lty=2)) grid.lines(x=c(0.6, 0.6), gp=gpar(lty=2)) 8.8 拆解 ggplot2 对象 grid.force() 后 可以使用 grid.ls() 查看ggplot2对象的是怎么由 grid 对象堆积的。 You can use the ggplotGrob function from the ggplot2 package to explicitly make a ggplot grob from a ggplot object. library(ggplot2) g_plot=ggplot(mtcars, aes(mpg, disp, color=factor(carb) ))+ geom_point()+ facet_grid(~gear)+ theme_bw()+ scale_color_manual(name=&quot;Carb&quot;, values = 2:7) g_plot grid.force() grid.ls() ## layout ## background.1-15-13-1 ## panel-1-1.8-5-8-5 ## grill.gTree.5356 ## panel.background..rect.5347 ## panel.grid.minor.y..polyline.5349 ## panel.grid.minor.x..polyline.5351 ## panel.grid.major.y..polyline.5353 ## panel.grid.major.x..polyline.5355 ## NULL ## geom_point.points.5338 ## NULL ## panel.border..rect.5344 ## panel-1-2.8-7-8-7 ## grill.gTree.5372 ## panel.background..rect.5363 ## panel.grid.minor.y..polyline.5365 ## panel.grid.minor.x..polyline.5367 ## panel.grid.major.y..polyline.5369 ## panel.grid.major.x..polyline.5371 ## NULL ## geom_point.points.5340 ## NULL ## panel.border..rect.5360 ## panel-1-3.8-9-8-9 ## grill.gTree.5388 ## panel.background..rect.5379 ## panel.grid.minor.y..polyline.5381 ## panel.grid.minor.x..polyline.5383 ## panel.grid.major.y..polyline.5385 ## panel.grid.major.x..polyline.5387 ## NULL ## geom_point.points.5342 ## NULL ## panel.border..rect.5376 ## strip-t-1.7-5-7-5 ## strip.1-1-1-1 ## strip.background.x..rect.5417 ## strip.text.x.top..titleGrob.5409 ## GRID.text.5407 ## strip-t-2.7-7-7-7 ## strip.1-1-1-1 ## strip.background.x..rect.5417 ## strip.text.x.top..titleGrob.5412 ## GRID.text.5410 ## strip-t-3.7-9-7-9 ## strip.1-1-1-1 ## strip.background.x..rect.5417 ## strip.text.x.top..titleGrob.5415 ## GRID.text.5413 ## axis-t-1.6-5-6-5 ## axis-t-2.6-7-6-7 ## axis-t-3.6-9-6-9 ## axis-b-1.9-5-9-5 ## NULL ## axis ## axis.1-1-1-1 ## axis.2-1-2-1 ## GRID.text.5391 ## axis-b-2.9-7-9-7 ## NULL ## axis ## axis.1-1-1-1 ## axis.2-1-2-1 ## GRID.text.5395 ## axis-b-3.9-9-9-9 ## NULL ## axis ## axis.1-1-1-1 ## axis.2-1-2-1 ## GRID.text.5399 ## axis-l-1.8-4-8-4 ## NULL ## axis ## axis.1-1-1-1 ## GRID.text.5403 ## axis.1-2-1-2 ## axis-r-1.8-10-8-10 ## xlab-t.5-9-5-5 ## xlab-b.10-9-10-5 ## GRID.text.5441 ## ylab-l.8-3-8-3 ## GRID.text.5444 ## ylab-r.8-11-8-11 ## guide-box.8-13-8-13 ## legend.box.background.2-4-4-2 ## guides.3-3-3-3 ## background.1-6-10-1 ## title.2-5-2-2 ## guide.title.titleGrob.5449 ## GRID.text.5447 ## key-3-1-bg.4-2-4-2 ## key-3-1-1.4-2-4-2 ## key-4-1-bg.5-2-5-2 ## key-4-1-1.5-2-5-2 ## key-5-1-bg.6-2-6-2 ## key-5-1-1.6-2-6-2 ## key-6-1-bg.7-2-7-2 ## key-6-1-1.7-2-7-2 ## key-7-1-bg.8-2-8-2 ## key-7-1-1.8-2-8-2 ## key-8-1-bg.9-2-9-2 ## key-8-1-1.9-2-9-2 ## label-3-3.4-4-4-4 ## guide.label.titleGrob.5452 ## GRID.text.5450 ## label-4-3.5-4-5-4 ## guide.label.titleGrob.5455 ## GRID.text.5453 ## label-5-3.6-4-6-4 ## guide.label.titleGrob.5458 ## GRID.text.5456 ## label-6-3.7-4-7-4 ## guide.label.titleGrob.5461 ## GRID.text.5459 ## label-7-3.8-4-8-4 ## guide.label.titleGrob.5464 ## GRID.text.5462 ## label-8-3.9-4-9-4 ## guide.label.titleGrob.5467 ## GRID.text.5465 ## subtitle.4-9-4-5 ## title.3-9-3-5 ## caption.11-9-11-5 ## tag.2-2-2-2 8.9 扩展 gridBase: — Integration of base and grid graphics gridGraphics — Redraw Base Graphics Using ‘grid’ Graphics. gridBezier — Bezier Curves in ‘grid.’ gridExtra Miscellaneous Functions for “Grid” Graphics forestplot gridtext, html, more 游戏框架 gridpattern — ‘grid’ Pattern Grobs. https://github.com/cran/gridGraphviz/blob/master/R/graph.R https://github.com/yjunechoe/gridAnnotate/blob/master/R/qdraw.R https://github.com/atofigh/gridheat/tree/master/R 8.10 ref https://www.cnblogs.com/ljhdo/p/4874785.html https://stat.ethz.ch/R-manual/R-patched/library/grid/doc/viewports.pdf https://stat.ethz.ch/R-manual/R-patched/library/grid/html/00Index.html https://bookdown.org/rdpeng/RProgDA/ just 参数 https://www.cnblogs.com/ywliao/archive/2018/08/30/9562180.html "],["good-resource.html", "Chapter 9 Good resource 9.1 单细胞教程(en) 9.2 单细胞教程(cn) 9.3 R 及 R包 教程", " Chapter 9 Good resource 9.1 单细胞教程(en) 纽约大学 Seurat: Integration and Label Transfer 9.2 单细胞教程(cn) xx 9.3 R 及 R包 教程 ComplexHeatmap 包 "],["intro.html", "Chapter 10 tables 10.1 how to make tables", " Chapter 10 tables 10.1 how to make tables You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 10. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter ??. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 10.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 10.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 10.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 10.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2021) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
